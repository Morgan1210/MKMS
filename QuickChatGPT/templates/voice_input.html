<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MKMS Voice (Local)</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,"PingFang SC",sans-serif; padding:16px; }
    button { font-size:18px; padding:12px 16px; border-radius:12px; border:1px solid #ddd; background:#fff; }
    #status { margin-top:12px; opacity:.7; }
    #text { margin-top:16px; white-space:pre-wrap; line-height:1.6; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .pill { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #eee; opacity:.8; }
  </style>
</head>
<body>
  <div class="row">
    <button id="btn">ðŸŽ¤ å¼€å§‹å½•éŸ³</button>
    <span class="pill" id="fmt">mime: -</span>
    <span class="pill" id="len">size: -</span>
  </div>

  <div id="status">Idle</div>
  <div id="text"></div>

  <script>
    const btn = document.getElementById('btn');
    const statusEl = document.getElementById('status');
    const textEl = document.getElementById('text');
    const fmtEl = document.getElementById('fmt');
    const lenEl = document.getElementById('len');

    // âœ… æœ¬åœ°åŒæºï¼šFlask åŒä¸€ä¸ª host:port ä¸‹çš„ /asr
    const API_URL = "/asr";

    let mediaRecorder = null;
    let chunks = [];
    let stream = null;
    let recording = false;

    const setStatus = (s) => statusEl.textContent = s;

    function pickMimeType() {
      const candidates = [
        "audio/webm;codecs=opus",
        "audio/webm",
        "audio/mp4",    // iOS Safari æœ‰æ—¶ä¼šæ”¯æŒ
        "audio/aac",
      ];
      for (const t of candidates) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) {
          return t;
        }
      }
      return ""; // è®©æµè§ˆå™¨è‡ªå·±é€‰
    }

    btn.onclick = async () => {
      if (!recording) {
        // START
        try {
          if (!navigator.mediaDevices?.getUserMedia) {
            throw new Error("å½“å‰çŽ¯å¢ƒä¸æ”¯æŒ getUserMediaï¼ˆéœ€è¦ HTTPS æˆ–æœ¬åœ° WKWebView é…ç½®ï¼‰");
          }

          stream = await navigator.mediaDevices.getUserMedia({ audio: true });

          const mimeType = pickMimeType();
          const options = mimeType ? { mimeType } : {};

          mediaRecorder = new MediaRecorder(stream, options);
          chunks = [];

          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) chunks.push(e.data);
          };

          mediaRecorder.onstart = () => {
            recording = true;
            btn.textContent = "â¹ åœæ­¢å¹¶æäº¤";
            setStatus("Recordingâ€¦");
            fmtEl.textContent = "mime: " + (mediaRecorder.mimeType || "auto");
            lenEl.textContent = "size: -";
          };

          mediaRecorder.onstop = async () => {
            setStatus("Uploading to local /asr â€¦");

            const blob = new Blob(chunks, { type: mediaRecorder.mimeType || "audio/webm" });
            lenEl.textContent = "size: " + blob.size + " bytes";

            const form = new FormData();
            // filename åŽç«¯å¯ä»¥ç”¨æ¥åˆ¤æ–­æ‰©å±•å
            const ext = (mediaRecorder.mimeType && mediaRecorder.mimeType.includes("mp4")) ? "mp4" : "webm";
            form.append("audio", blob, `recording.${ext}`);

            try {
              const resp = await fetch(API_URL, { method: "POST", body: form });
              if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

              const data = await resp.json();

              // åŽç«¯ä¸¤ç§æ¨¡å¼éƒ½å…¼å®¹ï¼š
              // 1) åªç¼“å­˜ï¼šè¿”å›ž {ok:true, file:"xxx.webm"}
              // 2) è¯†åˆ«ï¼šè¿”å›ž {text:"..."} æˆ– {ok:true, text:"..."}
              if (data.text) {
                textEl.textContent = data.text;
                setStatus("Done (ASR text received)");
              } else if (data.file) {
                textEl.textContent = `âœ… å·²ç¼“å­˜æœ¬åœ°æ–‡ä»¶ï¼š${data.file}`;
                setStatus("Done (audio saved locally)");
              } else {
                textEl.textContent = JSON.stringify(data, null, 2);
                setStatus("Done (unknown response)");
              }
            } catch (err) {
              console.error(err);
              setStatus("Error: " + err.message);
            } finally {
              // stop tracks
              stream?.getTracks()?.forEach(t => t.stop());
              recording = false;
              btn.textContent = "ðŸŽ¤ å¼€å§‹å½•éŸ³";
            }
          };

          mediaRecorder.start(); // æ•´æ®µå½•éŸ³
        } catch (err) {
          console.error(err);
          setStatus("Mic permission denied or error: " + err.message);
        }
      } else {
        // STOP
        try { mediaRecorder.stop(); } catch (e) {}
      }
    };
  </script>
</body>
</html>